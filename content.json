{"meta":{"title":"yxleung","subtitle":"小新的日常","description":"大数据 经济学 算法建模 机器学习 深度学习","author":"yxleung","url":"http://yxleung.github.io"},"pages":[{"title":"about","date":"2017-09-08T12:07:51.000Z","updated":"2018-01-02T09:09:55.443Z","comments":true,"path":"about/index.html","permalink":"http://yxleung.github.io/about/index.html","excerpt":"","text":"我是阿里的一名程序员！主要工作是数据分析、算法建模机器学习、大数据开发；业余兴趣是经济学，其实也是数据分析的一方面；建设这个blog主要是记录个人生活和工作中笔记，希望以后可以把自己的经验文档化落地； 我的Email：liangyuxin.02@gmail.com 欢迎大家找我交流！"}],"posts":[{"title":"交叉编译小米路由器2（R2D）shadowsocks","slug":"交叉编译小米路由器2（R2D）shadowsocks","date":"2018-01-02T09:33:01.000Z","updated":"2018-01-03T01:24:13.695Z","comments":true,"path":"2018/01/02/交叉编译小米路由器2（R2D）shadowsocks/","link":"","permalink":"http://yxleung.github.io/2018/01/02/交叉编译小米路由器2（R2D）shadowsocks/","excerpt":"","text":"交叉编译小米路由器2（R2D）shadowsocks背景： 我是使用 https://shadowsocks.la/ 提供的shadowsocks服务，由于最近服务商把shadowsocks加密方式换成了google的[chacha20-ietf-poly1305]，但是小米路由器（R2D）内置的ss-redir版本旧不支持。问题就来了，我一直在小米路由器做的透明代理（简单来说既是连接到这个路由的所有请求都自动走shadowsocks服务）就失效了;所以我需要更新R2D的ss-redir以便支持[chacha20-ietf-poly1305]加密;google后没有找到现成的，相关的文章也少，最后只能自己交叉编译一个，同时把编译过程记录下来，方便大家使用; 小白党，直接使用我编译： 最新版本openwrt-shadowsock下载链接https://github.com/yxleung/blog/raw/master/source/download/ss.zip 折腾党，我们手把手重新编译一次： 编译清单项目地址：https://github.com/shadowsocks/shadowsocks-libev编译环境：ubuntu小米路由器SDK：http://bigota.miwifi.com/xiaoqiang/sdk/tools/package/sdk_package.zip编译工具：make git autoconf libtool编译核心依赖：TLS pcre libsodium libev c-ares 下面的操作都在自己的home目录进行，我是临时用docker构建了个ubuntu编译的，所以都在/root目录下1、下载小米路由器SDK12wget http://bigota.miwifi.com/xiaoqiang/sdk/tools/package/sdk_package.zipunzip sdk_package.zip 2、设置环境变量123456export PATH=$PATH:/root/miwifi/sdk_package/toolchain/binexport CC=arm-xiaomi-linux-uclibcgnueabi-gccexport CXX=arm-xiaomi-linux-uclibcgnueabi-g++`#核心依赖包编译后放在这里mkdir /root/miwifi/ss_libexport SS_LIB=/root/miwifi/ss_lib 3、安装基础依赖包1apt install -y make git autoconf libtool 4、下载编译安装核心依赖包 编译mbedtls12345cd /root/miwifi/repowget --no-check-certificate https://tls.mbed.org/download/mbedtls-2.6.0-gpl.tgztar -xzvf mbedtls-2.6.0-gpl.tgzcd mbedtls-2.6.0make -j$(nproc) DESTDIR=$SS_LIB CC=arm-xiaomi-linux-uclibcgnueabi-gcc AR=arm-xiaomi-linux-uclibcgnueabi-ar LD=arm-xiaomi-linux-uclibcgnueabi-ld install 编译pcre123456cd /root/miwifi/repowget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gztar -xzvf pcre-8.41.tar.gzcd pcre-8.41./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=$SS_LIB --disable-shared --enable-utf8 --enable-unicode-propertiesmake -j$(nproc) install 编译libsodium123456cd /root/miwifi/repowget --no-check-certificate https://download.libsodium.org/libsodium/releases/libsodium-1.0.13.tar.gztar -xzvf libsodium-1.0.13.tar.gzcd libsodium-1.0.13./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=$SS_LIB --disable-ssp --disable-sharedmake -j$(nproc) install 编译libev123456cd /root/miwifi/repowget http://dist.schmorp.de/libev/libev-4.24.tar.gztar -xzvf libev-4.24.tar.gzcd libev-4.24./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=$SS_LIB --disable-sharedmake -j$(nproc) install 编译c-ares12345cd /root/miwifi/repowget --no-check-certificate https://c-ares.haxx.se/download/c-ares-1.13.0.tar.gztar -xzvf c-ares-1.13.0.tar.gzcd c-ares-1.13.0./configure LDFLAGS=-static --host=arm-xiaomi-linux-uclibcgnueabi --prefix=$SS_LIB 5、正式编译shadowsocks-libev123456789mkdir /root/miwifi/sscd /root/miwifi/repogit clone https://github.com/shadowsocks/shadowsocks-libevcd shadowsocks-libevgit submodule initgit submodule update./autogen.sh./configure LIBS=\"-lpthread -lm\" LDFLAGS=\"-Wl,-static -static -static-libgcc -L$SS_LIB/lib\" CFLAGS=\"-I$SS_LIB/include\" --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/root/miwifi/ss --disable-ssp --disable-documentation --with-mbedtls=$SS_LIB --with-pcre=$SS_LIB --with-sodium=$SS_LIBmake -j$(nproc) install 编译完成就可以看到/root/miwifi/ss目录下有编译好的文件，copy到小米路由器上跑就好了; 最近比较忙，没有把小米路由部署SS教程写出来，有空我就补上;有什么问题，可以直接email我，email地址在about页；","categories":[{"name":"technology","slug":"technology","permalink":"http://yxleung.github.io/categories/technology/"}],"tags":[{"name":"shadowsocks R2D 交叉编译 小米路由器 chacha20-ietf-poly1305","slug":"shadowsocks-R2D-交叉编译-小米路由器-chacha20-ietf-poly1305","permalink":"http://yxleung.github.io/tags/shadowsocks-R2D-交叉编译-小米路由器-chacha20-ietf-poly1305/"}]},{"title":"entropy-note-01","slug":"entropy-note-01","date":"2017-09-11T06:54:58.000Z","updated":"2018-01-02T09:09:55.440Z","comments":true,"path":"2017/09/11/entropy-note-01/","link":"","permalink":"http://yxleung.github.io/2017/09/11/entropy-note-01/","excerpt":"","text":"如何通俗易懂理解熵让我们说人话！好的数学概念都应该是通俗易懂的。 信息熵，信息熵，怎么看怎么觉得这个“熵”字不顺眼，那就先不看。我们起码知道这个概念跟信息有关系。而它又是个数学模型里面的概念，一般而言是可以量化的。所以，第一个问题来了：信息是不是可以量化？ 起码直觉上而言是可以的，不然怎么可能我们觉得有些人说的废话特别多，“没什么信息量”，有些人一语中的，一句话就传达了很大的信息量。 为什么有的信息量大有的信息量小？ 有些事情本来不是很确定，例如明天股票是涨还是跌。如果你告诉我明天NBA决赛开始了，这两者似乎没啥关系啊，所以你的信息对明天股票是涨是跌带来的信息量很少。但是假如NBA决赛一开始，大家都不关注股票了没人坐庄股票有99%的概率会跌，那你这句话信息量就很大，因为本来不确定的事情变得十分确定。 而有些事情本来就很确定了，例如太阳从东边升起，你再告诉我一百遍太阳从东边升起，你的话还是丝毫没有信息量的，因为这事情不能更确定了。 所以说信息量的大小跟事情不确定性的变化有关。 那么，不确定性的变化跟什么有关呢？ 一，跟事情的可能结果的数量有关；二，跟概率有关。先说一。例如我们讨论太阳从哪升起。本来就只有一个结果，我们早就知道，那么无论谁传递任何信息都是没有信息量的。当可能结果数量比较大时，我们得到的新信息才有潜力拥有大信息量。 二，单看可能结果数量不够，还要看初始的概率分布。例如一开始我就知道小明在电影院的有15*15个座位的A厅看电影。小明可以坐的位置有225个，可能结果数量算多了。可是假如我们一开始就知道小明坐在第一排的最左边的可能是99%，坐其它位置的可能性微乎其微，那么在大多数情况下，你再告诉我小明的什么信息也没有多大用，因为我们几乎确定小明坐第一排的最左边了。 那么，怎么衡量不确定性的变化的大小呢？怎么定义呢？ 这个问题不好回答，但是假设我们已经知道这个量已经存在了，不妨就叫做信息量，那么你觉得信息量起码该满足些什么特点呢？ 起码不是个负数吧，不然说句话还偷走信息呢~ 起码信息量和信息量之间可以相加吧！假如你告诉我的第一句话的信息量是3，在第一句话的基础上又告诉我一句话，额外信息量是4，那么两句话信息量加起来应该等于7吧！难道还能是5是9？ 刚刚已经提过，信息量跟概率有关系，但我们应该会觉得，信息量是连续依赖于概率的吧！就是说，某一个概率变化了0.0000001，那么这个信息量不应该变化很大。 刚刚也提过，信息量大小跟可能结果数量有关。假如每一个可能的结果出现的概率一样，那么对于可能结果数量多的那个事件，新信息有更大的潜力具有更大的信息量，因为初始状态下不确定性更大。 那有什么函数能满足上面四个条件呢？负的对数函数，也就是-log（x）！底数取什么都行。前面再随便乘个常数也行。 a. 为什么不是正的？因为假如是正的，由于x是小于等于1的数，log（x）就小于等于0了。第一个特点满足。 b. 咱们再来验证一下其他特点。三是最容易的。假如x是一个概率，那么log（x）是连续依赖于x的。done c。四呢？假如有n个可能结果，那么出现任意一个的概率是1/n，而-log(1/n)是n的增函数，没问题。 d。最后验证二。由于-log(xy) = -log(x) -log(y)，所以也是对的。学数学的同学注意，这里的y可以是给定x的条件概率，当然也可以独立于x。 By the way，这个函数是唯一的（除了还可以多乘上任意一个常数），有时间可以自己证明一下，或者查书。ok，所以我们知道一个事件的信息量就是这个事件发生的概率的负对数。 最后终于能回到信息熵。信息熵是跟所有可能性有关系的。每个可能事件的发生都有个概率。信息熵就是平均而言发生一个事件我们得到的信息量大小。所以数学上，信息熵其实是信息量的期望。（表达式参考其它答案或者看下面）$$H(x)=-\\sum_{x \\in U}P(x)\\log P(x)$$至于为什么用“熵”这个怪字？大概是当时翻译的人觉得这个量跟热力学的熵有关系，所以就用了这个字，君不见字里头的火字旁？熵最早是由热力学定义的一个函数，是普朗克来中国讲学的时候引入的。英文是“entropy”这个字，中文词汇中没有相关的字眼。当时是一个有名的姓胡的学者作为普朗克的翻译。因为这个熵“S”是定义为热量Q与温度的比值，所以当时他翻译是立刻创造出熵这个字，从火，从商。 作者：滴水链接：https://www.zhihu.com/question/26446385/answer/50029104来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"technology","slug":"technology","permalink":"http://yxleung.github.io/categories/technology/"}],"tags":[{"name":"特征工程 信息熵 香农熵 entropy","slug":"特征工程-信息熵-香农熵-entropy","permalink":"http://yxleung.github.io/tags/特征工程-信息熵-香农熵-entropy/"}]},{"title":"GNUroot debian android ssh设置","slug":"GNUroot-android-ssh","date":"2017-09-09T13:18:43.000Z","updated":"2018-01-02T09:09:55.434Z","comments":true,"path":"2017/09/09/GNUroot-android-ssh/","link":"","permalink":"http://yxleung.github.io/2017/09/09/GNUroot-android-ssh/","excerpt":"","text":"SSH设置123456# 安装opensshapt-get install openssh-server# 打开文件/etc/ssh/sshd_conifg,设置一下属性PermitRootLogin yes UsePAM noUsePrivilegeSeparation no 设置语言环境123456789101112131415# 查看语言库locale -a# 安装localesapt-get install locales# 生成语言文件locale-gen zh_CN.UTF-8dpkg-reconfigure localesvi /etc/default/locale LANG=zh_CN.UTF-8# 设置环境变量vi ~/.bash_profileexoprt LANG=&quot;zh_CN.UTF-8&quot;# 生效source .bash_profile 设置时间同步12345678910# 时间（时区）查看date -R# 安装时间同步程序apt-get install ntpdate# 同步时间ntpdate time.nist.gov# 选择时区（只是选择，选择后的结果需要copy到环境变量）tzselect# 设置环境变量vi ~/.bash_profileTZ=&apos;Asia/Shanghai&apos;; export TZ 命令别名1234# 设置环境变量vi ~/.bash_profilealias l=&apos;ls -alhF&apos;alias la=&apos;ls -AFh&apos;alias ll=&apos;ls -lhAF&apos;","categories":[{"name":"technology","slug":"technology","permalink":"http://yxleung.github.io/categories/technology/"}],"tags":[{"name":"gnuroot debian","slug":"gnuroot-debian","permalink":"http://yxleung.github.io/tags/gnuroot-debian/"}]},{"title":"tenserflow笔记-01","slug":"tenserflow-note-01","date":"2017-09-09T13:13:24.000Z","updated":"2018-01-02T09:09:55.437Z","comments":true,"path":"2017/09/09/tenserflow-note-01/","link":"","permalink":"http://yxleung.github.io/2017/09/09/tenserflow-note-01/","excerpt":"","text":"什么是神经网络让计算机自己去解决问题，神经网络就是一个函数，从训练数据集中求出多元方程组的解，之后使用这个函数，求出输入对应的预期输出。 简单来说，神经网络就是能够从训练数据集学习的函数。 使用神经网络过程： 首先要构建一个解决某一个问题的神经网络。（创建函数） 使用大量训练数据集，训练网络。（求解多元 方程组） 最终得到一个神经网络（函数），输入数据，输出期望信息。 简单原理1公式：W1x1 + W2x2 &gt; b W1、W2：weigh权重，用于改变分类直线的角度。神经元角度（W1、W2代表了输入与神经元连接的强度） b:bias 偏置，用于改变分类直线的位置。神经元角度（b表示一个神经元是否可被输入激活的阈值） 所以可以重复使用这个公式，分类任何可以被一条直线分类的数据集。问题：怎么找到W1、W2、b的值，即所谓参数值。 训练神经元，反向传播和梯度下降算法训练过程中的计算机会尝试一点点增大或减小每个参数，看其能如何减少相比于训练 数据集的误差，以望能找到最优的参数组合。 找到了W1，W2，b，即可以使用神经元做分类。一个神经元所能做的唯一事情：使用权重和偏置检查输入值，将一个数据点分到两类中的一类。 带有两个输入时，一个神经元可以使用一条直线将一个数据点在一个二维空间中分成两类。如果有三个输入，一个神经元可以使用一个平面将一个三维空间分成两部分，以此类推。这就是所谓的「使用一个超平面分割 n 维空间（dividing n-dimensional space with a hyperplane）」。 一个神经元可以将任何数据点分为两类隐含层使用隐含层，将输入变换为特征空间，把非线性的问题，使其线性分类。","categories":[{"name":"technology","slug":"technology","permalink":"http://yxleung.github.io/categories/technology/"}],"tags":[{"name":"tenserflow","slug":"tenserflow","permalink":"http://yxleung.github.io/tags/tenserflow/"}]}]}